### 주제

클래스와 객체

### 세부 주제

클래스, 객체, String, 불변

값과 참조

리플렉션, 어노테이션

제네릭

### 알아볼 것

1. 힙 객체 헤더
    1. https://mangkyu.tistory.com/448
2. Annotation Processor

---

## Object

<aside>
💡

Object 클래스는 **모든 클래스의 최상위 부모**로, 명시적으로 상속하지 않아도 자동으로 상속하게 된다.

> class Tiger →  class Tiger extends Object
> 
</aside>

Object 클래스는 **java.lang** 패키지 내에 존재한다.

- 부트스트랩 클래스 로더가 로딩
- 모든 클래스가 자동으로 상속하므로, 당연히 Object 클래스의 메소드를 사용할 수 있음

총 11개의 메소드가 존재하는데, 빈번하게 재정의되는 4가지와 추가로 중요한 한 가지를 살펴보겠다.

**[Tiger 클래스]**

![image.png](attachment:cefe1e09-e23f-43a5-a18c-bf7502d450e6:image.png)

### 1. `toString()`

toString() 메소드는 기본적으로 Object 클래스의 인스턴스에 대한 정보와 해시 코드를 문자열로 반환한다.

![image.png](attachment:eb7016d4-6565-461e-8ab2-357974d90d59:image.png)

아래 이미지에 써 있는 것처럼, 인스턴스에 대한 정보를 문자열로 제공하여 **사람이 읽기 위한 용도**로 쓰인다. 

![image.png](attachment:9904de51-04d0-41eb-ab75-a8f4a9a25ef0:image.png)

객체의 경우 해시 코드보단 필드 혹은 어떠한 값들로 보는 것이 편한 경우가 많다. 따라서 재정의하는 경우가 많다.

```java
public static void main(String[] args) {
        Tiger tiger = new Tiger("Tiger", 20);
        System.out.print(tiger); 
        // toString() 재정의 전 : study.Tiger@3b07d329
        // toString() 재정의 후 : 이름 : Tiger, 나이 : 20세
    }
```

### 2. `equals()`

![image.png](attachment:6b15e09c-3c6f-49b5-97eb-38ea88c725a3:image.png)

equals() 메소드는 **두 인스턴스의 주소 값을 비교**하여 boolean 값을 반환한다.

![image.png](attachment:4f8f5038-d0b3-4e1f-9894-9eb465e920d6:image.png)

- 기본적으로는 주소 값 비교
- 논리적으로 같다면 같다고 판단할 수 있도록 **재정의**하여 사용 가능

```java
Tiger t1 = new Tiger("Lion", 30);
Tiger t2 = new Tiger("Lion", 30);
System.out.println(t1 == t2); // false
System.out.println(t1.equals(t2));
// equals() 재정의 전 : false
// equals() 재정의 후 : true
```

### 3. `hashcode()`

hashCode()는 객체의 해시값을 반환하며, equals()를 재정의하면 반드시 hashCode()도 재정의해야 한다.

![image.png](attachment:6790c0c8-80b3-484e-87cd-de5699cc1a9f:image.png)

두 가지 규칙이 있다.

1. equals()가 true면 hashCode()도 같아야 한다.
2. hashCode()가 같아도 equals()는 false일 수 있다. (해시 충돌)

```java
Tiger t1 = new Tiger("Lion", 30);
Tiger t2 = new Tiger("Lion", 30);
System.out.println(t1.hashCode());
System.out.println(t2.hashCode());
// hashCode() 재정의 전 : 990368553, 1096979270
// hashCode() 재정의 후 : 73426723, 73426723
```

equals()와 hashCode()를 함께 재정의하지 않는다면?

```java
Set<Tiger> set = new HashSet<>();
Tiger t1 = new Tiger("Cat", 25);
Tiger t2 = new Tiger("Cat", 25);

// equals()만 재정의하고 hashCode()는 안 했다면:
// t1.equals(t2) == true
// t1.hashCode() != t2.hashCode() (Object 기본: 주소 기반)
// → HashSet이 다른 버킷에 저장 → 중복 허용돼버림!
```

****) 참고**

![image.png](attachment:5a0c86fe-8dc9-4a7f-815e-8ed0f13a7b8d:image.png)

1. **@IntrinsicCandidate**
    1. 자주 호출될 것 같으니 JVM에게 최적화하라는 힌트를 주기 위해 사용
2. **native 키워드**
    1. 자바에는 선언만 있고, 실제 구현은 JNI로 OS / JVM 내부 코드에서 수행
    2. JVM이 호출 → JNI → C 코드 실행

### 4. `clone()`

clone() 메소드는 인스턴스 **객체의 복제**를 위한 메소드로, 해당 인스턴스를 복제하여 새로운 인스턴스를 생성해서 그 참조값을 반환한다.

![image.png](attachment:d5e0f6c7-328c-4a2b-8df4-3c43065b952c:image.png)

- 객체의 클래스가 **Cloneable 인터페이스를 구현**해야 함
- clone()의 기본은 얕은 복사!

**얕은 복사**

**참조만 복사**하고, 내부 객체는 공유하는 복사 방식이다.

![image.png](attachment:23b9579b-a959-498b-940a-258e5520b8d0:image.png)

**깊은 복사**

**내부 객체까지 모두 새로 생성**하는 복사 방식이다.

![image.png](attachment:3971a034-77d7-4805-a286-82d613f36b3d:image.png)

### 5. `getClass()`

getClass() 메소드는 런타임에 **객체의 클래스 정보**를 반환한다.

```java
Tiger tiger = new Tiger("Monkey", 3);
Class<? extends Tiger> clazz = tiger.getClass();
System.out.print(clazz.getName()); // "Tiger"
```

- Class 타입의 clazz 객체를 반환함

‘클래스 로딩’의 ‘로딩’ 단계에서 java.lang.Class 객체를 힙 메모리에 생성한다. Class 객체는 클래스 로딩 시 Heap에 생성되는 객체로, 클래스의 메타 데이터이자 통로가 된다.

<aside>
💡

**Class 클래스 자체**는 JVM 시작할 때 Bootstrap ClassLoader가 로드한다. 

‘java.lang.Class’는 **모든 클래스의 메타데이터를 표현하는 클래스**로, JVM에 로드된 모든 클래스/인터페이스는 각각 대응되는 Class 객체를 가진다.

</aside>

- **Class 클래스 자체**는 JVM 시작할 때 Bootstrap ClassLoader가 로드함
- **각 클래스의 Class 객체**는 해당 클래스가 로딩될 때 생성됨

로딩 시 힙에 만들어지는 건 **MyClass 객체**가 아니라 **Class<MyClass> 객체**다.

```java
new MyClass();      // 이건 내가 직접 만드는 MyClass 인스턴스 → Heap
MyClass.class;      // 이건 JVM이 로딩 시 만든 Class<MyClass> 객체 → Heap

MyClass 로딩
    ↓
힙에 Class<MyClass> 객체 1개 생성 (메타데이터 접근용)
    ↓
new MyClass() 할 때마다 MyClass 인스턴스 생성 (별개)
```

Class 클래스는 "클래스에 대한 정보를 담는 클래스"다.

```java
Class<MyClass> clazz = MyClass.class;

clazz.getName();          // "com.example.MyClass"
clazz.getMethods();       // 메서드 목록
clazz.getFields();        // 필드 목록
clazz.newInstance();      // 인스턴스 생성
clazz.getClassLoader();   // 누가 로드했는지
```

**instanceof와의 차이**

| 구분 | 의미 | 언제 true |
| --- | --- | --- |
| `instanceof` | “이 타입이거나 그 하위 타입인가?” | 상속/구현 포함 |
| `getClass()` | “정확히 같은 타입인가?” | 동일 클래스일 때만 |

## 문자열

### 1. String 객체

기본적으로 String은 **불변 객체**다. 기본형이 아닌 참조형이므로 heap에 저장되며, 한 번 생성되면 내용을 변경할 수 없다.

![image.png](attachment:96057aa3-7553-45f0-aa70-05c1f1bf7448:image.png)

**불변인 이유?**

1. Thread-Safe
2. 해시값 캐싱
    
    ![image.png](attachment:19aeddb8-58f6-4141-81b2-782972065631:image.png)
    
3. 보안
    1. 외부 드라이버나 통신의 경우 connect를 위한 URL을 String으로 주고받는데, 가변이면 보안 상 문제가 발생할 수 있다.
4. String Pool 활용
    1. String은 불변이므로 같은 문자열을 안전하게 공유할 수 있다.

### 2. String Pool

String Pool은 JVM이 문자열 리터럴을 관리하는 특별한 메모리 영역이다. 

![image.png](attachment:557549cd-8b86-474d-af92-c1506059c017:image.png)

- 리티럴로 생성 시 String Pool에서 같은 객체를 꺼내서 사용
- new 연산자로 String 객체 생성 시 새로운 객체를 heap에 생성

### 3. intern() 메소드

String의 intern() 메소드는 String Pool에 리터럴 문자열이 이미 존재하는지 확인한다. 존재하면 해당 문자열을 반환하고, 존재하지 않으면 해당 리터럴을 String Pool에 넣어준다.

```java
String s1 = "hello";                    // Pool에 저장
String s2 = new String("hello");        // 힙에 생성
String s3 = s2.intern();                // Pool의 "hello" 반환

System.out.println(s1 == s2);  // false
System.out.println(s1 == s3);  // true (같은 Pool 객체)
```

- String Pool에 “hello”와 같은 내용의 String이 있는지 확인
    - 존재 : String Pool의 해당 String 참조 반환
    - 존재 X : String Pool에 등록하고, 참조 반환

### 4. 문자열 다루기

**‘+’ 연산자**

```java
String result = "a" + "b" + "c";  // 컴파일러가 최적화
// 컴파일 후: String result = "abc";

String s = "hello";
String result = s + " world";  // 런타임에 처리
// 컴파일 후: new StringBuilder(s).append(" world").toString();
```

- 리터럴만 이어 붙일 때는 컴파일러가 미리 합쳐서 하나의 문자열 상수로 만듦
    - 실행 시점 연산 X / String Pool에 합쳐진 하나의 문자열만 만들어짐
- 변수가 섞이면 런타임에 처리됨
- **반복문에서 주의**해야 함
    
    ```java
    // 나쁜 예: 매번 새 객체 생성
    String result = "";
    for (int i = 0; i < 10000; i++) {
        result += i;  // 매번 StringBuilder 생성 → String 변환
    }
    
    // 좋은 예: StringBuilder 재사용
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 10000; i++) {
        sb.append(i);
    }
    String result = sb.toString();
    ```
    
    **나쁜 예의 내부 동작:**
    ```
    반복 1: new StringBuilder("").append(0).toString() → "0"
    반복 2: new StringBuilder("0").append(1).toString() → "01"
    반복 3: new StringBuilder("01").append(2).toString() → "012"
    ...
    10000번 반복: StringBuilder 10000개 생성, String 10000개 생성
    ```
    

**String vs StringBuilder vs StringBuffer**

![image.png](attachment:f20c48de-2d8a-46c2-b247-139643209110:image.png)

|  | String | StringBuilder | StringBuffer |
| --- | --- | --- | --- |
| **가변성** | 불변 | 가변 | 가변 |
| **Thread-Safe** | O (불변) | X | O (synchronized) |
| **성능** | 연결 많으면 느림 | 빠름 | StringBuilder보다 느림 
/ String보다 빠름 |
| **사용 상황** | 변경 적을 때 | 단일 스레드, 문자열 조작 많을 때 | 멀티 스레드 |

## 값과 참조

### **Call By Value vs Call By Reference**

<aside>
💡

자바는 항상 Call By Value다. 무조건 값을 복사해서 전달하며, **참조 타입 또한 참조값(주소)를 복사**한다.

</aside>

**Call By Value**

- 함수에 ‘값의 복사본’을 넘김
- 함수 내부에서 파라미터를 바꿔도 원래 변수가 변하지 않음
    - 호출된 함수 내부의 스택에 존재하는 변수가 변하는 것

**Call By Reference**

- 함수에 변수 자체(주소)를 넘김
- 함수 내부에서 파라미터를 바꾸면 원래 변수가 변함
    - 참조 - 메모리 주소로 생각

```cpp
void reassign(Person& p) {  // &는 참조
    p = Person("Park");     // 원본 변수 자체가 바뀜
}
```

### **참조 타입 파라미터**

**Case 1 : 객체 내부 수정 → 반영**

**Case 2 : 참조 자체 변경 → 반영 X**

![image.png](attachment:567c680b-002d-4f74-ab1e-8ad1e3d63214:image.png)

어떤 것이 힙과 스택 어디에 있는지 잘 구분할 것!

## 리플렉션

<aside>
💡

리플렉션은 **런타임**에 클래스의 구조를 분석하고 조작하는 기능이다. 이를 사용하면 컴파일 타임에 알 수 없는 클래스도 런타임에 동적으로 다룰 수 있다.

</aside>

JVM 클래스를 로드하면 **OS 네이티브 메모리에 메타데이터가 적재**된다. 리플렉션을 사용하면 생성자, 메소드, 필드 등과 같은 클래스에 대한 정보에 접근할 수 있다.

### 1. 클래스 정보 로드

- 클래스가 Method Area에 로드됨
- 로딩 과정에서 Heap에 Class 객체 생성

리플렉션은 이 Class 객체를 통해 메타데이터에 접근 가능!

### 2. 리플렉션 사용 흐름

**Class 객체 얻기**

Heap에 저장된 Class 객체를 통해 클래스의 메타데이터에 접근해야 한다. 메타데이터에 접근하기 위한 세 가지 방법이 있다.

```java
// 방법 1: 클래스를 알 때
Class<Tiger> aClass = Tiger.class;

// 방법 2: 인스턴스가 있을 때
Tiger tiger = new Tiger();
Class<? extends Tiger> bClass = tiger.getClass();

// 방법 3: 클래스 이름(문자열)만 알 때 -> 프레임워크가 주로 사용
Class<?> cClass = Class.forName("study.Tiger");
```

**생성자로 인스턴스 생성**

```java
Class<?> clazz = Class.forName("study.Tiger");
Constructor<?> constructor = clazz.getDeclaredConstructor(); // 기본 생성자 가져오기
Object object = constructor.newInstance(); // 인스턴스 생성
```

**메소드 호출**

```java
Method method = clazz.getDeclaredMethod("cry");
method.invoke(object);
```

### 3. 왜 Class 객체를 통해 접근하는가?

Metaspace에 직접 접근하지 않고 왜 Class 객체를 통해 접근하는가?

- Metaspace는 JVM 내부, 네이티브 메모리
    - 따라서 Java 코드에서 직접 메모리 주소로 접근할 수 없음
- Class 객체 : Metaspace의 데이터를 Java 코드에서 다룰 수 있게 해 줌

**그렇다면 클래스 이름은 어떻게 알아오는가?**

**컴포넌트 스캔**은 **디스크에서 시작**

- `@ComponentScan(basePackages = "com.example")`
- Spring은 “com.example” 패키지에 어떤 클래스가 있는지 ‘디스크’에서 살펴봄

**호출** 시 **클래스 로딩**

- `Class<?> clazz = Class.forName(className);`
- 디스크 → 메모리(JVM) 클래스 로딩

**클래스 로딩 후 메타데이터 조회**

- `clazz.isAnnotationPresent(~~.class);`
- `class.getDeclaredFields();`

### 4. Spring에서의 간단한 예시

```java
// 1. 컴포넌트 스캔: @Service 붙은 클래스 찾기
Class<?> clazz = Class.forName("com.example.UserService");
if (clazz.isAnnotationPresent(Service.class)) {
    
    // 2. 인스턴스 생성
    Constructor<?> constructor = clazz.getDeclaredConstructor();
    Object bean = constructor.newInstance();
    
    // 3. 의존성 주입: @Autowired 붙은 필드 찾기
    for (Field field : clazz.getDeclaredFields()) {
        if (field.isAnnotationPresent(Autowired.class)) {
            
            // 4. 해당 타입의 빈 찾기
            Class<?> fieldType = field.getType();  // UserRepository.class
            Object dependency = beanContainer.get(fieldType);
            
            // 5. 필드에 주입
            field.setAccessible(true);
            field.set(bean, dependency);
        }
    }
    // 6. 빈 컨테이너에 등록
    beanContainer.put(clazz, bean);
}
```

컴포넌트 스캔 → 클래스 찾기 → 인스턴스 생성 → 의존성 주입 → 빈 등록

Class.forName   isAnnotation   newInstance    field.set
                               present

### 5. 단점

- **성능**
    - 일반 호출보다 훨씬 느림
        - 메소드 이름으로 검색
        - 파라미터 타입 검증
        - 접근 권한 검사
        - JIT 최적화 어려움 등
- **타입 안전성**
    - 런타임에 진행하므로 컴파일 타임에 오류 검출 불가
- **캡슐화 위반**
    - `field.setAccessible(true)` : private도 접근 가능

## 어노테이션

<aside>
💡

어노테이션은 코드에 메타데이터를 추가하는 방법으로, `@`기호를 사용한다.

</aside>

어노테이션은 그 자체로 아무 동작도 하지 않고, 누군가 읽고 그에 맞게 처리해야 의미가 생긴다.

![image.png](attachment:dcdc9baf-8018-4a7a-b02a-7d7df12298e0:image.png)

### 1. `@Target`

`@Target`은 해당 어노테이션을 어디에 붙일 수 있는지 표시한다.

```java
public enum ElementType {
    TYPE,              // 클래스, 인터페이스, enum, record 선언 위치에 적용 (예: @Deprecated class A {})
    FIELD,             // 필드(멤버 변수)에 적용 (static/instance 모두)
    METHOD,            // 메서드 선언에 적용
    PARAMETER,         // 메서드/생성자 파라미터(매개변수)에 적용
    CONSTRUCTOR,       // 생성자 선언에 적용
    LOCAL_VARIABLE,    // 지역 변수에 적용 (메서드 내부 변수 등)
    ANNOTATION_TYPE,   // 어노테이션 자체의 선언에 적용 (메타 어노테이션)
    PACKAGE,           // 패키지 선언에 적용 (package-info.java)
    TYPE_PARAMETER,    // 제네릭 타입 파라미터에 적용 (예: <@NonNull T>)
    TYPE_USE,          // 타입이 사용되는 모든 위치에 적용 (변수 타입, 캐스트, new, 배열 요소 등)
    MODULE,            // 자바 모듈 선언(module-info.java)에 적용
    RECORD_COMPONENT   // record 의 필드 구성요소에 적용
}

```

### 2. `@Retention`

![image.png](attachment:f7e9f031-e29f-4c02-9d8c-88a85dbb4852:image.png)

`@Retention`은 어노테이션이 언제까지 유지되는지를 표시한다.

```java
public enum RetentionPolicy {
    SOURCE,   // 소스 코드까지만 존재. 컴파일 시 제거됨 (런타임/바이트코드에 없음) / 개발자 도구, 경고 표시용
    CLASS,    // .class 파일까지 존재. JVM 로딩 시 버려짐 (리플렉션으로는 못 봄)
              // (기본값 — 명시 안 하면 보통 이거) / 컴파일러/툴링
    RUNTIME   // 런타임까지 유지. 리플렉션으로 조회 가능 (Spring, Hibernate 등에서 자주 사용)
}

```

위 두 가지 외에도 여러 표준 어노테이션이 존재한다. 커스텀 시에는 위 두 개를 주의깊게 살펴보고, 추가하도록 하자!

### 3. 리플렉션으로 어노테이션 읽기

어노테이션은 리플렉션을 기반으로 사용된다. 아무 의미 없는 어노테이션에 의미를 불어넣어 줄 수 있다.

```java
Method method = clazz.getMethod("myMethod");
if (method.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
    System.out.println(annotation.value());  // "test"
    System.out.println(annotation.count());  // 5
}
```

## 제네릭

<aside>
💡

제네릭은 타입을 파라미터화해서 컴파일 타임에 타입 안정성을 보장한다.
즉, 타입을 클래스 내부에서 지정하는 것이 아닌, 외부에서 사용자에 의해 지정되는 것이다.

</aside>

### 1. 제네릭 메소드

제네릭 메소드는 클래스와 별개로 메소드 단위로 타입 파라미터를 선언한다. 제네릭 클래스는 인스턴스 생성 시 타입이 결정되는 반면, 제네릭 메소드는 호출할 때마다 타입이 결정된다.

```java
// 제네릭 클래스: 인스턴스 생성 시 타입 결정
public class Box<T> {
    public T get() { ... }
}
Box<String> box = new Box<>();  // T = String으로 고정

// ----------------------------------------------------------

// 제네릭 메서드: 호출 시마다 타입 결정
public class Util {
    public static <T> T getFirst(List<T> list) { ... }
}
Util.getFirst(List.of("a", "b"));  // T = String
Util.getFirst(List.of(1, 2, 3));   // T = Integer
```

- 제네릭 메소드는 타입 파라미터의 사용 범위가 메소드 내로 한정됨

**타입 추론**

제네릭 메소드를 사용할 때는 타입을 추론한다. 호출 시 타입이 결정되기 때문이다.

- 파라미터 타입 추론
    - 제네릭 메소드 호출 시 들어오는 파라미터로 T 타입을 추론
- 리턴 타입 추론
    - 제네릭 메소드 호출 후 반환하는 결과를 어디에 담느냐에 따라 T타입을 추론

### 2. 범위 한정 (Bounded Type Parameter)

<aside>
💡

제네릭을 사용하면(<T>) 타입에 구애받지 않고 자유롭게 코드를 작성할 수 있다. 하지만, 너무 자유롭기에, 허용되지 않는 타입이 들어갈 수 있다.

</aside>

**상한 제한(Upper Bound)**

- 특정 타입 또는 그 하위 타입만 허용
- `public class Calculator<T extends Number>`: T는 Number 또는 Number의 하위 클래스만 가능

**다중 제한**

- `public class NumberBox<T extends Number & Comparable<T>>`: T는 Number를 상속하고 Comparable을 구현해야 함

### 3. 와일드카드

<aside>
💡

와일드카드는 모든 타입을 대신하여 사용될 수 있다. `?`키워드를 사용한다.

</aside>

**상한 경계 와일드카드**

- 와일드카드 타입에 extends를 사용해서 최상위 타입을 정의하여 상한 경계 설정
- `List<? extends Number>`: Integer, Double, Long … 여러 가지 가능 / 특정 불가능
    - Number 혹은 그 윗 타입으로 꺼내야 함

원소를 꺼낼 때 자식 타입으로 꺼내면 안 된다. 어떤 자식이 뽑힐지 모르기 때문에, 부모 혹은 그 부모의 조상 타입으로 꺼내야 한다.

**하한 경계 와일드카드**

- 와일드카드 타입에 super를 사용해서 최하위 타입을 정의하여 하한 경계 설정
- `List<? super Integer> list = ???` : Integer, Number, Object… 특정 불가능
    - Integer로 넣어야 함 → 실제로 Integer, Number, Object 모든 경우에 Integer는 가능

마찬가지로 원소를 컬렉션에 추가하는 경우, 하한 경계로 설정된 타입으로 넣어야 한다.

**PECS 원칙 : Producer-Extends, Consumer-Super** 

위에서 살짝 나온 것처럼 꺼낼 때는 상한 경계, 넣을 때는 하한 경계를 신경 써야 한다.

- 데이터를 읽을 때(Produce) : `<? extends T>`
- 데이터를 쓸 때(Consume) : `<? super T>`

읽고 쓰는 데 자유롭지만, **특정할 수 있는지**를 잘 따져보아야 한다!

### 4. 타입 소거 (Type Erasure) / 미완

<aside>
💡

제네릭 타입 정보는 컴파일 후 제거된다. 따라서 런타임에는 제네릭 타입인지 알 수 없다. (바이트 코드에는 제네릭이 존재하지 않음)

</aside>

타입 소거 규칙

1. 무제한 타입 파라미터 → Object
    1. Box<T> → T : Object
2. 상한 제한 타입 파라미터 → 상한 타입
    1. Calculator<T extends Number> → T : Number
3. 필요한 곳에 캐스트 삽입![alt text](<image (18).png>) ![alt text](<image (19).png>) ![alt text](<image (20).png>) ![alt text](<image (21).png>) ![alt text](<image (22).png>) ![alt text](<image (23).png>) ![alt text](<image (24).png>) ![alt text](<image (25).png>) ![alt text](<image (26).png>) ![alt text](<image (27).png>) ![alt text](<image (28).png>) ![alt text](<image (29).png>) ![alt text](<image (30).png>) ![alt text](<image (31).png>) ![alt text](<image (32).png>) ![alt text](<image (33).png>) ![alt text](<image (34).png>)